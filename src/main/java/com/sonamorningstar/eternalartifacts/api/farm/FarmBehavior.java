package com.sonamorningstar.eternalartifacts.api.farm;

import net.minecraft.core.BlockPos;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.sounds.SoundEvent;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import org.jetbrains.annotations.NotNull;

import javax.annotation.Nullable;
import java.util.List;

/**
 * Defines the behavior for handling farming logic such as planting, harvesting,
 * seed validation, and block interactions for a specific type of crop or plant.
 * <p>
 * A {@code FarmBehavior} encapsulates the logic required for the farming worker
 * to interact with growable blocks in the world. Different plants (wheat, sugar
 * cane, cocoa, bamboo, kelp, berries, etc.) can each have their own behavior
 * implementation.
 * </p>
 *
 * <h3>Priority System</h3>
 * Multiple behaviors may match the same block or seed. For example, {@link net.minecraft.world.level.block.TorchflowerCropBlock}
 * might match both a {@link com.sonamorningstar.eternalartifacts.api.farm.behaviors.CropBehavior} behavior and a specialized
 * Torchflower behavior({@link com.sonamorningstar.eternalartifacts.api.farm.behaviors.TorchFlowerBehavior}). To resolve conflicts, each behavior has a
 * {@link #getPriority()} value:
 * <ul>
 *     <li>Higher priority value → tested earlier</li>
 *     <li>Lower priority value → tested later</li>
 * </ul>
 * <p>
 * Behaviors are {@link Comparable} by priority, so registry containers can
 * automatically keep them sorted.
 * </p>
 */
public interface FarmBehavior extends Comparable<FarmBehavior> {
	/**
	 * Checks whether the given ItemStack is a valid seed for this behavior.
	 * <p>
	 * Called before planting and testing for appropriate item in harvesters seed slot
	 * to determine which behavior is responsible for
	 * handling a seed. A behavior should return {@code true} only if that seed
	 * can be planted and grown according to this behavior's logic.
	 * </p>
	 *
	 * @param seedStack the seed ItemStack to evaluate
	 * @return {@code true} if this behavior recognizes the seed as plantable
	 */
	boolean isCorrectSeed(ItemStack seedStack);
	
	/**
	 * Determines whether this behavior applies to the block present at the
	 * given world position.
	 * <p>
	 * This is used to detect which crop or plant type is currently growing at
	 * the given location. Behaviors with higher priority values are tested
	 * first.
	 * </p>
	 *
	 * @param level the world the block is located in
	 * @param pos   the block position to test
	 * @return {@code true} if this behavior can interact with the target block
	 */
	boolean matches(Level level, BlockPos pos);
	
	/**
	 * Determines whether the plant at the given position is ready to be
	 * harvested.
	 * <p>
	 * This typically checks properties like age (e.g. age == max) or height.
	 * </p>
	 *
	 * @param level the world
	 * @param pos   the block position of the plant
	 * @return {@code true} if the crop is mature and can be harvested
	 */
	boolean canHarvest(Level level, BlockPos pos);
	
	/**
	 * Computes the BlockState that should be placed when the farm machine
	 * plants this behavior’s crop on the given soil.
	 * <p>
	 * The returned state must represent the "freshly planted" version of the
	 * crop (e.g. age = 0). The seed ItemStack is provided to allow behaviors
	 * to derive planting properties from it if needed.
	 * </p>
	 *
	 * @param level the world
	 * @param pos   the position where the plant will be placed
	 * @param seed  the seed stack used for planting
	 * @return the {@link BlockState} representing the newly planted crop
	 */
	BlockState getPlantingState(Level level, BlockPos pos, ItemStack seed);
	
	/**
	 * Harvests the plant at the given position and returns the list of drops
	 * generated by the harvesting process.
	 * <p>
	 * The default implementation uses Minecraft's built-in loot table logic by
	 * calling {@link Block#getDrops(BlockState, ServerLevel, BlockPos, BlockEntity)}
	 * and then destroys the block without dropping items into the world.
	 * </p>
	 * <p>
	 * Behaviors may override this to produce custom drop logic or preserve
	 * special blocks.
	 * </p>
	 *
	 * @param level the world
	 * @param pos   the position of the crop
	 * @param tool  optional tool used to harvest (e.g. hoe), may be null
	 * @return a list of ItemStacks collected from harvesting
	 */
	default List<ItemStack> harvest(Level level, BlockPos pos, @Nullable ItemStack tool, @Nullable Entity harvester) {
		BlockState state = level.getBlockState(pos);
		var drops = Block.getDrops(state, (ServerLevel) level, pos, level.getBlockEntity(pos),
			harvester, tool == null ? ItemStack.EMPTY : tool);
		level.destroyBlock(pos, false);
		return drops;
	}
	
	/**
	 *
	 * @param level the world
	 * @param pos   the position of the crop
	 * @param tool  optional tool used to harvest (e.g. hoe), may be null
	 * @return the {@link com.sonamorningstar.eternalartifacts.core.ModFluids#SLUDGE Sludge} amount that will
	 * be produced by the {@link com.sonamorningstar.eternalartifacts.content.block.entity.Harvester Harvester} after
	 * the {@link #harvest(Level, BlockPos, ItemStack, Entity) harvesting} process
	 */
	int getSludgeAmount(Level level, BlockPos pos, @Nullable ItemStack tool);
	
	/**
	 * Indicates whether this behavior supports automatic replanting after
	 * harvesting.
	 * <p>
	 * Some plants do not replant themselves (e.g. flowers and {@link com.sonamorningstar.eternalartifacts.api.farm.behaviors.GlowBerryBehavior}).
	 * Returning {@code false} prevents the farm machine from
	 * replanting after harvesting.
	 * </p>
	 *
	 * @return {@code true} if the plant can be replanted automatically
	 */
	default boolean supportsReplanting() { return true; }
	
	/**
	 * Priority value used to resolve conflicts when multiple behaviors match
	 * the same block or seed.
	 * <p>
	 * Higher values indicate higher priority. The behavior with the highest
	 * priority is applied first.
	 * </p>
	 *
	 * @return the priority value for this behavior
	 */
	default int getPriority() { return 100; }
	
	/**
	 * Compares farm behaviors by priority in descending order.
	 * <p>
	 * A behavior with a higher priority value is considered "less" in sort
	 * order so that it appears earlier.
	 * </p>
	 *
	 * @param o the other FarmBehavior
	 * @return comparison result based on priority
	 */
	@Override
	default int compareTo(@NotNull FarmBehavior o) {
		return Integer.compare(o.getPriority(), this.getPriority());
	}
	
	/**
	 * Returns the sound played when replanting occurs.
	 * <p>
	 * Behaviors may override this to use custom sounds depending on plant
	 * type (e.g. stem crops, vine crops, saplings, etc.).
	 * </p>
	 *
	 * @param state the {@link BlockState} that is being placed
	 * @return the {@link SoundEvent} used during planting
	 */
	default SoundEvent getReplantSound(BlockState state) {
		return state.getSoundType().getPlaceSound();
	}
	
	/**
	 * Returns the {@link BlockState} to place after harvesting when replanting should
	 * occur.
	 * <p>
	 * The default implementation simply calls {@link #getPlantingState(Level,
	 * BlockPos, ItemStack)} again using the same seed.
	 * </p>
	 *
	 * @param level the world
	 * @param pos   the position of the plant
	 * @param seed  the seed ItemStack
	 * @return the replanted {@link BlockState}
	 */
	default BlockState getReplantingState(Level level, BlockPos pos, ItemStack seed) {
		return getPlantingState(level, pos, seed);
	}
}
